# 8Ã—8 Wallace Tree Multiplier  

This repository contains a **structural Verilog implementation** of an 8Ã—8 unsigned Wallace tree multiplier, along with a testbench, documentation, and simulation results.  

---

## ğŸ‘¨â€ğŸ’» Skills & Tools Showcased  
- Structural Verilog for digital design  
- RTL development of combinational circuits  
- Modular design using Half/Full Adders and AND gates  
- Testbench creation and waveform verification  
- Simulation with Vivado/ModelSim  
- Formal documentation with LaTeX  

---

## ğŸ› ï¸ Key Features  
- Fully structural **8Ã—8 Wallace tree multiplier**  
- Hierarchical design with modular Verilog subcomponents  
- Verified with **comprehensive test vectors and waveforms**  
- Detailed **gate count and complexity analysis**  
- Supporting diagrams (hand-drawn + LaTeX generated)  
- Report with reflections and design insights  

---

## ğŸ“‚ Repository Structure  
/src â†’ Verilog source files + testbenches
/sim â†’ Simulation results (waveforms, scripts, screenshots)
/docs â†’ Project report, diagrams, and gate count analysis


---

## ğŸ“„ Report & Schematics  

You can view the detailed report, including block diagrams and schematic drawings, at:  
[Wallace Adder Schematics (PDF)](https://github.com/ReewajAdhikari/Wallace-Multiplier/blob/main/WallaceAdder%20Schematics.pdf)

---

## ğŸš¦ Running the Project  
1. Clone the repository.  
2. Open in **Vivado** or **ModelSim**.  
3. Add all files from `/src`.  
4. Run the provided testbenches.  
5. Compare results against reference outputs in `/sim`.  

---

## ğŸ“ Documentation  
The full report is available in [`/docs/Project1_Report.pdf`]([/](https://github.com/ReewajAdhikari/Wallace-Multiplier/blob/main/8x8%Wallace%Report.pdf), including:  
- Block and gate-level diagrams  
- Gate count and design complexity  
- Simulation results and analysis  
- Reflections on challenges and learnings  

---

## ğŸ“Œ Notes  
This project was developed as part of a **digital design coursework** to explore efficient hardware multipliers and their trade-offs compared to conventional array multipliers.  

